{"meta":{"title":"Sjsurf","subtitle":"Trick or Theat It's your up.","description":"a iOSer","author":"Sjsurf","url":"https://sjsurf.github.io"},"pages":[],"posts":[{"title":"test","slug":"test","date":"2017-01-22T07:37:46.000Z","updated":"2017-01-22T07:38:41.000Z","comments":true,"path":"2017/01/22/test/","link":"","permalink":"https://sjsurf.github.io/2017/01/22/test/","excerpt":"","text":"test1 tag","categories":[],"tags":[{"name":"test1","slug":"test1","permalink":"https://sjsurf.github.io/tags/test1/"}]},{"title":"ARC","slug":"ARC","date":"2017-01-22T06:26:16.000Z","updated":"2017-01-22T06:27:21.000Z","comments":true,"path":"2017/01/22/ARC/","link":"","permalink":"https://sjsurf.github.io/2017/01/22/ARC/","excerpt":"","text":"ARCAutomatic Reference Counting,即自动引用计数，在iOS5中引入的内存管理机制。该机制使得开发者无需键入retain和release降低了程序崩溃和内存泄露的风险，但是ARC不支持Core Foundation ARC的实现clang(LLVM编译器)3.0以上和obj4 Object-C运行时库493.9以上共同组成。 1. __Strong修饰符在定义一个obj对象的时候 123&#123; id _Strong obj = [[NSObject alloc] init]&#125; 编译器的的做了如下操作 123id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_relase(obj); 调用一个方法，意味着使用objc_msgSend函数发送一条消息，在作用域结束时，调用objc_relase函数来释放对象。 在除了alloc/new/copy/mutableCopy等方法之外的方法，编译器还会生成objc_retainAutorelasedReturnValue和objc_autoRelaseReturnvalue函数，objc_retainAutorelasedReturnValue方法的作用为最优化程序运行。objc_autoRelaseReturnvalue作用于返回对象的实现上。 12345id _Strong obj = [[NSMutableArray alloc] init];+ (id)array &#123; return[[NSMutableArray alloc] init];&#125; 上面这段代码转换后为 123456789101112id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutorelasedReturnValue(obj);+ (id)array &#123; id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoRelaseReturnValue(obj);&#125;objc_relase(obj)//请注意，我合并了两个作用域的代码，所以对象obj的relase应该在作用域的最后一块 返回注册到autorelasepool中对象的方法使用了objc_autoRelaseReturnValue函数返回注册到autorelasepool中的对象。 若方法在或函数在执行objc_autoRelaseReturnValue函数之后马上执行了objc_retainAutorelasedReturnValue函数，那么就不将返回的对象注册到autoreleasepool中，而是直接传递到函数方法或者函数的调用方。 通过objc_autoRelaseReturnValue与objc_retainAutorelasedReturnValue函数的协作，可以不将对象注册到autoreleasepool中且直接进行传递，达到了最优化的目的。 2.__weak修饰符 若变量被__weak修饰，被所引用的对象所抛弃，则将nil赋值给该变量。 变量被__weak修饰，等同于使用一个被注册到autoreleasepool的对象。 1234&#123; id __weak obj1 = obj; //假设obj为__Strong修饰并且被赋值。&#125; 定义一个__weak修饰的变量的编译器模拟代码为 123456&#123; //代码2-2 id obj1; objc_initWeak(&amp;obj1,obj); objc_destoryWeak(&amp;obj1);&#125; 在objc_initWeak将附有__weak修饰符的变量初始化为0后，会调用objc_storeWeak函数，objc_destoryWeak会将0作为参数调用objc_storeWeak函数。所以我们可以得到代码2-2等效的代码. 123456&#123; id obj1; obj1 = 0; objc_storeWeak(&amp;obj1,obj1; objc_storeWeak(&amp;obj1,0);&#125; objc_storeWeak将第二参数赋值对象的地址作为键值，将第一参数的附有__weak修饰符的变量的地址注册到weak表中，若第二个参数为0，则把变量的地址从weak表中移除。 weak表与引用计数表相同，作为散列表被实现。 废弃一个谁都不持有的对象的过程 12345671. objc_release//因为引用计数为02. dealloc3. _objc_rootDealloc4. object_dispose5. objc_destructInstance6. objc_clear_deallocating 最后的objc_clear_deallocating将会执行的动作为 从weak表中获取废弃对象的地址为键值的记录 将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil 从weak表中删除该条记录 从引用计数表中删除废弃对象的地址为键值的记录 weak修饰符的特性第一条目标达成，但是根据过程可以看到，如果声明了大量的weak修饰符修饰的变量，将会占据大量的cpu资源，所以，原则上只为避免循环引用时才会使用weak修饰符。 不能使用__weak修饰符的情况 部分类重写了retain/release方法并实现了该类肚子的引用计数机制。由于重写了自己的引用计数机制的大部分类并不能支持objc4运行时库的函数，而想要使用__weak修饰符的变量必须恰当的运行objc4运行时库，所以，这些类大多不支持__weak修饰符。 当allowsWeakReference与retainWeakReference实例方法放回的BOOL值为NO时，如果当前变量附有修饰符__weak且allowsWeakReference返回NO程序将会异常终止。如果retainWeakReference返回值为NO该变量将会使用nil。 举例的话 1234567891011121314151617181920//定义NSObject的子类，然后重写retainWeakReference方法@interface MyObject ()@property (nonatomic, assign) NSInteger count;@end@implementation MyObject- (BOOL)retainWeakReference &#123; if (++ self.count &gt; 3) &#123; return NO; &#125; else &#123; return super.retainWeakReference; &#125;&#125;@end 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; id obj = [[MyObject alloc] init]; id __weak test = obj; NSLog(@&quot;1 : %@&quot;, test); NSLog(@&quot;2 : %@&quot;, test); NSLog(@&quot;3 : %@&quot;, test); NSLog(@&quot;4 : %@&quot;, test); NSLog(@&quot;5 : %@&quot;, test); &#125; return 0;&#125; 123456//Main方法中反复使用__weak属性5此，但是由于在MyObject类中，我们重写了retainWeakReference方法（调用三次以上retainWeakReference方法就会返回NO），所以我们最后得到的结果为：2016-07-27 22:55:47.900 CommandLineLearn[1660:24252] 1 : &lt;MyObject: 0x100102350&gt;2016-07-27 22:55:47.901 CommandLineLearn[1660:24252] 2 : &lt;MyObject: 0x100102350&gt;2016-07-27 22:55:47.901 CommandLineLearn[1660:24252] 3 : &lt;MyObject: 0x100102350&gt;2016-07-27 22:55:47.901 CommandLineLearn[1660:24252] 4 : (null)2016-07-27 22:55:47.901 CommandLineLearn[1660:24252] 5 : (null)","categories":[],"tags":[]}]}